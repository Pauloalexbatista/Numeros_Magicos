'use server';

import { getHistory } from '@/app/actions';
import { BacktestService } from '@/services/backtest';
import { RandomModel } from '@/models/implementations/RandomModel';
import { HotNumbersModel } from '@/models/implementations/HotNumbersModel';
import { ColdNumbersModel } from '@/models/implementations/ColdNumbersModel';
import { BalancedMixModel } from '@/models/implementations/BalancedMixModel';
import { PatternBasedModel } from '@/models/implementations/PatternBasedModel';
import { MLClassifierModel } from '@/models/implementations/MLClassifierModel';
import { BacktestResult, PredictionModel, PredictionResult, Draw } from '@/models/types';
import { HotStarsModel, ColdStarsModel, RandomStarsModel } from '@/models/implementations/StarModels';
import { getSystemByName, IPredictiveSystem } from '@/services/ranked-systems';

// Adapter to use IPredictiveSystem as PredictionModel
class SystemToModelAdapter implements PredictionModel {
    id: string;
    name: string;
    description: string;
    private system: IPredictiveSystem;

    constructor(system: IPredictiveSystem) {
        this.id = system.name.toLowerCase().replace(/\s+/g, '_');
        this.name = system.name;
        this.description = system.description;
        this.system = system;
    }

    async predict(history: Draw[], predictionSize: number = 5): Promise<PredictionResult> {
        // IPredictiveSystem expects history (Draw[] from Prisma), but we have Draw[] from types (date is string)
        // We need to map it back to what the system expects (date as Date object)
        const prismaHistory = history.map(d => ({
            ...d,
            date: new Date(d.date),
            // Ensure other fields match if strict. 
            // Prisma Draw has numbers as string, types Draw has numbers as number[].
            // We need to stringify numbers/stars to match Prisma Draw interface if strict.
            // However, most systems use parseNumbers helper which handles both.
            // Let's cast to any to bypass strict type check for now.
        })) as any[];

        const numbers = await this.system.generateTop10(prismaHistory);

        // Ensure we respect predictionSize
        const sliced = numbers.slice(0, predictionSize);

        return {
            numbers: sliced,
            reasoning: `Generated by ${this.name}`
        };
    }
}

export async function runBacktestAction(modelId: string, testDrawsCount: number, predictionSize: number = 5): Promise<BacktestResult> {
    const history = await getHistory();

    // Map history to ensure date is a string for the Draw interface
    const mappedHistory = history.map(draw => ({
        ...draw,
        date: draw.date.toISOString()
    }));

    let model: PredictionModel;
    let type: 'numbers' | 'stars' = 'numbers';

    switch (modelId) {
        case 'random_baseline':
            model = new RandomModel();
            break;
        case 'hot_numbers_50':
        case 'hot_numbers':
            model = new HotNumbersModel();
            break;
        case 'cold_numbers_50':
        case 'cold_numbers':
            model = new ColdNumbersModel();
            break;
        case 'balanced_mix':
            model = new BalancedMixModel();
            break;
        case 'pattern_based':
            model = new PatternBasedModel();
            break;
        case 'ml_logistic_regression':
            model = new MLClassifierModel();
            break;

        // --- New Systems (via Adapter) ---
        case 'sist_media_camadas':
        case 'sist_media_3_otimizado':
        case 'sist_combinado_media_3':
        case 'mdiasemaspontas':
        case 'pyramid_pascal':
        case 'pyramid_gaps':
        case 'vortex_pyramid':
            const sysNameMap: Record<string, string> = {
                'sist_media_camadas': 'Sistema Média Camadas',
                'sist_media_3_otimizado': 'Sist Média + 3 Otimizado',
                'sist_combinado_media_3': 'Sist Combinado Media+3',
                'mdiasemaspontas': 'média sem as pontas',
                'pyramid_pascal': 'PyramidPascal',
                'pyramid_gaps': 'PyramidGaps',
                'vortex_pyramid': 'Vortex Pyramid'
            };
            const sysName = sysNameMap[modelId];
            const sys = getSystemByName(sysName);
            if (!sys) throw new Error(`System ${sysName} not found`);
            model = new SystemToModelAdapter(sys);
            break;

        // Stars Models
        case 'hot_stars':
            model = new HotStarsModel();
            type = 'stars';
            break;
        case 'cold_stars':
            model = new ColdStarsModel();
            type = 'stars';
            break;
        case 'random_stars':
            model = new RandomStarsModel();
            type = 'stars';
            break;
        default:
            throw new Error(`Model ${modelId} not found`);
    }

    return BacktestService.runBacktest(model, mappedHistory, testDrawsCount, predictionSize, type);
}
